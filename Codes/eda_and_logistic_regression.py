# -*- coding: utf-8 -*-
"""EDA and logistic regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13GAzxe6WhFGa_Hk9TWSSTVAQS_X3jfKE
"""

import numpy as np
import pandas as pd
from pathlib import Path
from collections import defaultdict

# Commented out IPython magic to ensure Python compatibility.
import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import seaborn as sns
from wordcloud import WordCloud, get_single_color_func #For creating word cloud
#import geopandas as gpd #For creating choropleth
import imageio #For creating the gif of choropleths
# %matplotlib inline

# Libraries for building classifiers
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC

"""**Read in Data**"""

names = pd.read_csv('name_gender_dataset.csv')
names.columns = ['Name', 'Gender', "Count", 'Probability']

data = pd.read_csv("gender_names_final.csv")

"""**Convert names to lowercase**"""

data['Name'] = data['Name'].apply(lambda x: x.lower())

"""**Length of a name**"""

males = data.loc[data.Gender == 0]
females = data.loc[data.Gender == 1]
males= males[["Name", "Gender", "Count"]]
females= females[["Name", "Gender", "Count"]]

males['len'] = [len(x) for x in males.Name]
females['len'] = [len(x) for x in females.Name]

male_names_len = males.len.value_counts().sort_index()
female_names_len = females.len.value_counts().sort_index()

fig,ax = plt.subplots(figsize=[15,6])
labels = np.arange(1,20)
width=0.35
plt.bar(male_names_len.index, male_names_len.values, 
        width=width, color='teal', label='Male Name Length')
plt.bar(female_names_len.index+width, female_names_len.values,
        width=width, color='crimson', label='Female Name Length')
plt.xticks(male_names_len.index+0.15, labels)
plt.xlabel('Length of a name')
plt.ylabel('Number of names')
plt.legend()
plt.show()

fig,ax = plt.subplots(figsize=[15,6])
labels = np.arange(1,20)

ax = sns.boxplot(x="index", y="values", data=male_names_len, orient="h")
ay = sns.boxplot(x="index", y="values", data=female_names_len, orient="h")

"""**Last letter vowel or not**"""

males['last_letter'] = [x[-1] for x in males.Name]
females['last_letter'] = [x[-1] for x in females.Name]

vowel_m = males.loc[(males.last_letter == 'a')|
                    (males.last_letter == 'e')|
                    (males.last_letter == 'i')|
                    (males.last_letter == 'o')|
                    (males.last_letter == 'u')]

vowel_f = females.loc[(females.last_letter == 'a')|
                    (females.last_letter == 'e')|
                    (females.last_letter == 'i')|
                    (females.last_letter == 'o')|
                    (females.last_letter == 'u')]

fig,ax = plt.subplots(1,2, figsize=[12,8])
vowels_m_count = vowel_m.last_letter.value_counts().sort_index()
vowels_f_count = vowel_f.last_letter.value_counts().sort_index()

labels = ['a','e','i','o','u']

ax[0].pie(vowels_m_count.values, labels=labels, autopct='%1.1f%%', startangle=90)
ax[0].set_title('Males')
ax[1].pie(vowels_f_count.values, labels=labels, autopct='%1.1f%%', startangle=90)
ax[1].set_title('Females')

""" **Top names by gender**"""

print(males.sort_values(by=['Count'], ascending=False).head(5))

print(females.sort_values(by=['Count'], ascending=False).head(5))

plt.style.use('ggplot')

names = ['linda','jennifer','patricia','elizabeth','mary', 'james','john','robert', 'michael','william']
ticks = np.arange(0, len(names))
labels = [5,4,3,2,1,1,2,3,4,5]
values = [1,2,3,4,5,5,4,3,2,1]
colors = ['cyan','darkturquoise','cadetblue','teal','darkslategrey',
          'maroon','brown','firebrick','indianred','salmon']

fig = plt.subplots(figsize=[15,6])
bar = plt.bar(ticks, values, color=colors)
plt.ylim(0,6)
plt.yticks([])
plt.xticks(ticks, labels)
plt.xlabel('Ranks')

for rect, name in zip(bar, names):
    height = rect.get_height()
    plt.text(rect.get_x() + rect.get_width()/2.0, height, s=name, 
             ha='center', va='bottom', fontsize=12)

"""**Classifying names into genders**

Segregating the names according to the assigned gender
"""

data = data[["Name", "Gender"]]
data['chk'] = 1

data['name_len'] = data['Name'].apply(lambda x: len(x))

data['last_letter_vowel'] = data['Name'].apply(lambda x: 1 if x[-1] in ['a','e','i','o','u'] else 0)

def letter_class(name):
    name_list = [x for x in name]
    vowel_counter = 0
    consonent_counter = 0
    for letter in name_list:
        if letter in ['a','e','i','o','u']:
            vowel_counter+=1
        else:
            consonent_counter+=1
    
    return vowel_counter, consonent_counter

data['num_vowels'] = data['Name'].apply(lambda x: letter_class(x)[0])
data['num_consonents'] = data['Name'].apply(lambda x: letter_class(x)[1])

def ascii_mean(name):
    ascii_list = [ord(x) for x in name]
    return np.array(ascii_list).mean()

data['ascii_value'] = data['Name'].apply(lambda x: ascii_mean(x).round(3))

def name_convertor(name_list):
    ndf = pd.DataFrame([], columns=['name','ascii_value','name_len',
                                    'num_vowels','num_consonents','last_letter_vowel', 
                                   ])
    ndf['name'] = name_list
    ndf['ascii_value'] = ndf['name'].apply(lambda x: ascii_mean(x).round(3))
    ndf['name_len'] = ndf['name'].apply(lambda x: len(x))
    ndf['last_letter_vowel'] = ndf['name'].apply(lambda x: 1 if x[-1] in ['a','e','i','o','u'] else 0)
    ndf['num_vowels'] = ndf['name'].apply(lambda x: letter_class(x)[0])
    ndf['num_consonents'] = ndf['name'].apply(lambda x: letter_class(x)[1])
    
    return ndf

data['class'] = data['Gender'].apply(lambda x: 1 if x==1 else 0)

dataset = data[['ascii_value','name_len', 'num_vowels','num_consonents','last_letter_vowel','class']]

"""Classifying  genders from namesÂ¶"""

X = dataset.iloc[:,:-1].values
y = dataset.iloc[:,-1].values

X_train, X_test, y_train, y_test = train_test_split(
                                    X, y, test_size=0.3, random_state=42)

print('Size of training set = ', X_train.shape[0])
print('Size of testing set = ', X_test.shape[0])

"""**Model 1: Logistic Regression**


"""

logreg = LogisticRegression(random_state=42).fit(X_train, y_train)

y_predict_logreg = logreg.predict(X_test)

cf_matrix = pd.crosstab(y_test, y_predict_logreg, normalize='index')

fig = plt.subplots(figsize=[6,6])
fig = sns.heatmap(cf_matrix, 
            fmt='.2%',
            annot=True, 
            cmap='Greens',
            cbar=False)

plt.xticks([0.5, 1.5], ['Male','Female'])
plt.yticks([0.5, 1.5], ['Male','Female'])
plt.xlabel('Predicted Genders')
plt.ylabel('Actual Genders')

pd.DataFrame(classification_report(y_test, y_predict_logreg, output_dict=True))

from sklearn.metrics import confusion_matrix, accuracy_score
acc =  accuracy_score(y_test, y_predict_logreg)
print(acc)







